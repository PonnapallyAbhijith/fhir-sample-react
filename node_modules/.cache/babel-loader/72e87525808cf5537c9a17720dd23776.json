{"ast":null,"code":"\"use strict\";\n/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.humanizeError = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;\n\nconst HttpError_1 = require(\"./HttpError\");\n\nconst settings_1 = require(\"./settings\");\n\nconst debug = require(\"debug\"); // $lab:coverage:off$\n// @ts-ignore\n\n\nconst {\n  fetch\n} = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"); // $lab:coverage:on$\n\nconst _debug = debug(\"FHIR\");\n\nexports.debug = _debug;\n/**\n * The cache for the `getAndCache` function\n */\n\nconst cache = {};\n/**\n * A namespace with functions for converting between different measurement units\n */\n\nexports.units = {\n  cm({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"cm\") return value;\n    if (code == \"m\") return value * 100;\n    if (code == \"in\") return value * 2.54;\n    if (code == \"[in_us]\") return value * 2.54;\n    if (code == \"[in_i]\") return value * 2.54;\n    if (code == \"ft\") return value * 30.48;\n    if (code == \"[ft_us]\") return value * 30.48;\n    throw new Error(\"Unrecognized length unit: \" + code);\n  },\n\n  kg({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"kg\") return value;\n    if (code == \"g\") return value / 1000;\n    if (code.match(/lb/)) return value / 2.20462;\n    if (code.match(/oz/)) return value / 35.274;\n    throw new Error(\"Unrecognized weight unit: \" + code);\n  },\n\n  any(pq) {\n    ensureNumerical(pq);\n    return pq.value;\n  }\n\n};\n/**\n * Assertion function to guard arguments for `units` functions\n */\n\nfunction ensureNumerical({\n  value,\n  code\n}) {\n  if (typeof value !== \"number\") {\n    throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n  }\n}\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\n\n\nasync function checkResponse(resp) {\n  if (!resp.ok) {\n    throw await humanizeError(resp);\n  }\n\n  return resp;\n}\n\nexports.checkResponse = checkResponse;\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\n\nfunction responseToJSON(resp) {\n  return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\nexports.responseToJSON = responseToJSON;\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\n\nfunction request(url, options = {}) {\n  return fetch(url, Object.assign(Object.assign({\n    mode: \"cors\"\n  }, options), {\n    headers: Object.assign({\n      accept: \"application/json\"\n    }, options.headers)\n  })).then(checkResponse).then(res => {\n    const type = res.headers.get(\"Content-Type\") + \"\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      return responseToJSON(res).then(body => ({\n        res,\n        body\n      }));\n    }\n\n    if (type.match(/^text\\//i)) {\n      return res.text().then(body => ({\n        res,\n        body\n      }));\n    }\n\n    return {\n      res\n    };\n  }).then(({\n    res,\n    body\n  }) => {\n    // Some servers will reply after CREATE with json content type but with\n    // empty body. In this case check if a location header is received and\n    // fetch that to use it as the final result.\n    if (!body && res.status == 201) {\n      const location = res.headers.get(\"location\") + \"\";\n\n      if (location) {\n        return request(location, Object.assign(Object.assign({}, options), {\n          method: \"GET\",\n          body: null\n        }));\n      }\n    } // For any non-text and non-json response return the Response object.\n    // This to let users decide if they want to call text(), blob() or\n    // something else on it\n\n\n    if (body === undefined) {\n      return res;\n    } // Otherwise just return the parsed body (can also be \"\" or null)\n\n\n    return body;\n  });\n}\n\nexports.request = request;\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\n\nfunction getAndCache(url, requestOptions, force = process.env.NODE_ENV === \"test\") {\n  if (force || !cache[url]) {\n    cache[url] = request(url, requestOptions);\n    return cache[url];\n  }\n\n  return Promise.resolve(cache[url]);\n}\n\nexports.getAndCache = getAndCache;\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\n\nfunction fetchConformanceStatement(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n  return getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the conformance statement from \"${url}\". ${ex}`);\n  });\n}\n\nexports.fetchConformanceStatement = fetchConformanceStatement;\n/**\n * Given a response object, generates and throws detailed HttpError.\n * @param resp The `Response` object of a failed `fetch` request\n */\n\nasync function humanizeError(resp) {\n  let msg = `${resp.status} ${resp.statusText}\\nURL: ${resp.url}`;\n  let body = null;\n\n  try {\n    const type = resp.headers.get(\"Content-Type\") || \"text/plain\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      body = await resp.json();\n\n      if (body.error) {\n        msg += \"\\n\" + body.error;\n\n        if (body.error_description) {\n          msg += \": \" + body.error_description;\n        }\n      } else {\n        msg += \"\\n\\n\" + JSON.stringify(body, null, 4);\n      }\n    } else if (type.match(/^text\\//i)) {\n      body = await resp.text();\n\n      if (body) {\n        msg += \"\\n\\n\" + body;\n      }\n    }\n  } catch (_) {// ignore\n  }\n\n  throw new HttpError_1.default(msg, resp.status, resp.statusText, body);\n}\n\nexports.humanizeError = humanizeError;\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\n\nfunction getPath(obj, path = \"\") {\n  path = path.trim();\n\n  if (!path) {\n    return obj;\n  }\n\n  let segments = path.split(\".\");\n  let result = obj;\n\n  while (result && segments.length) {\n    const key = segments.shift();\n\n    if (!key && Array.isArray(result)) {\n      return result.map(o => getPath(o, segments.join(\".\")));\n    } else {\n      result = result[key];\n    }\n  }\n\n  return result;\n}\n\nexports.getPath = getPath;\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\n\nfunction setPath(obj, path, value, createEmpty = false) {\n  path.trim().split(\".\").reduce((out, key, idx, arr) => {\n    if (out && idx === arr.length - 1) {\n      out[key] = value;\n    } else {\n      if (out && out[key] === undefined && createEmpty) {\n        out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n      }\n\n      return out ? out[key] : undefined;\n    }\n  }, obj);\n  return obj;\n}\n\nexports.setPath = setPath;\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\n\nfunction makeArray(arg) {\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n\n  return [arg];\n}\n\nexports.makeArray = makeArray;\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\n\nfunction absolute(path, baseUrl) {\n  if (path.match(/^http/)) return path;\n  if (path.match(/^urn/)) return path;\n  return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\nexports.absolute = absolute;\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\n\nfunction randomString(strLength = 8, charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") {\n  const result = [];\n  const len = charSet.length;\n\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * len)));\n  }\n\n  return result.join(\"\");\n}\n\nexports.randomString = randomString;\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\n\nfunction jwtDecode(token, env) {\n  const payload = token.split(\".\")[1];\n  return payload ? JSON.parse(env.atob(payload)) : null;\n}\n\nexports.jwtDecode = jwtDecode;\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse\n * @param env\n */\n\nfunction getAccessTokenExpiration(tokenResponse, env) {\n  const now = Math.floor(Date.now() / 1000); // Option 1 - using the expires_in property of the token response\n\n  if (tokenResponse.expires_in) {\n    return now + tokenResponse.expires_in;\n  } // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n\n\n  if (tokenResponse.access_token) {\n    let tokenBody = jwtDecode(tokenResponse.access_token, env);\n\n    if (tokenBody && tokenBody.exp) {\n      return tokenBody.exp;\n    }\n  } // Option 3 - if none of the above worked set this to 5 minutes after now\n\n\n  return now + 300;\n}\n\nexports.getAccessTokenExpiration = getAccessTokenExpiration;\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCode(observations, property) {\n  const ret = {};\n\n  function handleCodeableConcept(concept, observation) {\n    if (concept && Array.isArray(concept.coding)) {\n      concept.coding.forEach(({\n        code\n      }) => {\n        if (code) {\n          ret[code] = ret[code] || [];\n          ret[code].push(observation);\n        }\n      });\n    }\n  }\n\n  makeArray(observations).forEach(o => {\n    if (o.resourceType === \"Observation\" && o[property]) {\n      if (Array.isArray(o[property])) {\n        o[property].forEach(concept => handleCodeableConcept(concept, o));\n      } else {\n        handleCodeableConcept(o[property], o);\n      }\n    }\n  });\n  return ret;\n}\n\nexports.byCode = byCode;\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCodes(observations, property) {\n  const bank = byCode(observations, property);\n  return (...codes) => codes.filter(code => code + \"\" in bank).reduce((prev, code) => prev.concat(bank[code + \"\"]), []);\n}\n\nexports.byCodes = byCodes;\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\n\nfunction getPatientParam(conformance, resourceType) {\n  // Find what resources are supported by this server\n  const resources = getPath(conformance, \"rest.0.resource\") || []; // Check if this resource is supported\n\n  const meta = resources.find(r => r.type === resourceType);\n\n  if (!meta) {\n    throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n  } // Check if any search parameters are available for this resource\n\n\n  if (!Array.isArray(meta.searchParam)) {\n    throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n  } // This is a rare case but could happen in generic workflows\n\n\n  if (resourceType == \"Patient\" && meta.searchParam.find(x => x.name == \"_id\")) {\n    return \"_id\";\n  } // Now find the first possible parameter name\n\n\n  const out = settings_1.patientParams.find(p => meta.searchParam.find(x => x.name == p)); // If there is no match\n\n  if (!out) {\n    throw new Error(\"I don't know what param to use for \" + resourceType);\n  }\n\n  return out;\n}\n\nexports.getPatientParam = getPatientParam;\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\n\nasync function getTargetWindow(target, width = 800, height = 720) {\n  // The target can be a function that returns the target. This can be\n  // used to open a layer pop-up with an iframe and then return a reference\n  // to that iframe (or its name)\n  if (typeof target == \"function\") {\n    target = await target();\n  } // The target can be a window reference\n\n\n  if (target && typeof target == \"object\") {\n    return target;\n  } // At this point target must be a string\n\n\n  if (typeof target != \"string\") {\n    _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n\n    return self;\n  } // Current window\n\n\n  if (target == \"_self\") {\n    return self;\n  } // The parent frame\n\n\n  if (target == \"_parent\") {\n    return parent;\n  } // The top window\n\n\n  if (target == \"_top\") {\n    return top;\n  } // New tab or window\n\n\n  if (target == \"_blank\") {\n    let error,\n        targetWindow = null;\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps window.open was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Popup window\n\n\n  if (target == \"popup\") {\n    let error,\n        targetWindow = null; // if (!targetWindow || targetWindow.closed) {\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\"height=\" + height, \"width=\" + width, \"menubar=0\", \"resizable=1\", \"status=0\", \"top=\" + (screen.height - height) / 2, \"left=\" + (screen.width - width) / 2].join(\",\"));\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps the popup window was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Frame or window by name\n\n\n  const winOrFrame = frames[target];\n\n  if (winOrFrame) {\n    return winOrFrame;\n  }\n\n  _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n\n  return self;\n}\n\nexports.getTargetWindow = getTargetWindow;","map":{"version":3,"sources":["C:/Users/abhijith.ponnapally/smart-react-app-template/node_modules/fhirclient/lib/lib.js"],"names":["Object","defineProperty","exports","value","getTargetWindow","getPatientParam","byCodes","byCode","getAccessTokenExpiration","jwtDecode","randomString","absolute","makeArray","setPath","getPath","humanizeError","fetchConformanceStatement","getAndCache","request","responseToJSON","checkResponse","units","debug","HttpError_1","require","settings_1","fetch","FHIRCLIENT_PURE","window","_debug","cache","cm","code","ensureNumerical","Error","kg","match","any","pq","resp","ok","text","then","length","JSON","parse","url","options","assign","mode","headers","accept","res","type","get","body","status","location","method","undefined","requestOptions","force","process","env","NODE_ENV","Promise","resolve","baseUrl","String","replace","catch","ex","msg","statusText","json","error","error_description","stringify","_","default","obj","path","trim","segments","split","result","key","shift","Array","isArray","map","o","join","createEmpty","reduce","out","idx","arr","arg","strLength","charSet","len","push","charAt","Math","floor","random","token","payload","atob","tokenResponse","now","Date","expires_in","access_token","tokenBody","exp","observations","property","ret","handleCodeableConcept","concept","observation","coding","forEach","resourceType","bank","codes","filter","prev","concat","conformance","resources","meta","find","r","searchParam","x","name","patientParams","p","target","width","height","self","parent","top","targetWindow","open","e","screen","winOrFrame","frames"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.humanizeError = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;\n\nconst HttpError_1 = require(\"./HttpError\");\n\nconst settings_1 = require(\"./settings\");\n\nconst debug = require(\"debug\"); // $lab:coverage:off$\n// @ts-ignore\n\n\nconst {\n  fetch\n} = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"); // $lab:coverage:on$\n\nconst _debug = debug(\"FHIR\");\n\nexports.debug = _debug;\n/**\n * The cache for the `getAndCache` function\n */\n\nconst cache = {};\n/**\n * A namespace with functions for converting between different measurement units\n */\n\nexports.units = {\n  cm({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"cm\") return value;\n    if (code == \"m\") return value * 100;\n    if (code == \"in\") return value * 2.54;\n    if (code == \"[in_us]\") return value * 2.54;\n    if (code == \"[in_i]\") return value * 2.54;\n    if (code == \"ft\") return value * 30.48;\n    if (code == \"[ft_us]\") return value * 30.48;\n    throw new Error(\"Unrecognized length unit: \" + code);\n  },\n\n  kg({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"kg\") return value;\n    if (code == \"g\") return value / 1000;\n    if (code.match(/lb/)) return value / 2.20462;\n    if (code.match(/oz/)) return value / 35.274;\n    throw new Error(\"Unrecognized weight unit: \" + code);\n  },\n\n  any(pq) {\n    ensureNumerical(pq);\n    return pq.value;\n  }\n\n};\n/**\n * Assertion function to guard arguments for `units` functions\n */\n\nfunction ensureNumerical({\n  value,\n  code\n}) {\n  if (typeof value !== \"number\") {\n    throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n  }\n}\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\n\n\nasync function checkResponse(resp) {\n  if (!resp.ok) {\n    throw await humanizeError(resp);\n  }\n\n  return resp;\n}\n\nexports.checkResponse = checkResponse;\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\n\nfunction responseToJSON(resp) {\n  return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\nexports.responseToJSON = responseToJSON;\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\n\nfunction request(url, options = {}) {\n  return fetch(url, Object.assign(Object.assign({\n    mode: \"cors\"\n  }, options), {\n    headers: Object.assign({\n      accept: \"application/json\"\n    }, options.headers)\n  })).then(checkResponse).then(res => {\n    const type = res.headers.get(\"Content-Type\") + \"\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      return responseToJSON(res).then(body => ({\n        res,\n        body\n      }));\n    }\n\n    if (type.match(/^text\\//i)) {\n      return res.text().then(body => ({\n        res,\n        body\n      }));\n    }\n\n    return {\n      res\n    };\n  }).then(({\n    res,\n    body\n  }) => {\n    // Some servers will reply after CREATE with json content type but with\n    // empty body. In this case check if a location header is received and\n    // fetch that to use it as the final result.\n    if (!body && res.status == 201) {\n      const location = res.headers.get(\"location\") + \"\";\n\n      if (location) {\n        return request(location, Object.assign(Object.assign({}, options), {\n          method: \"GET\",\n          body: null\n        }));\n      }\n    } // For any non-text and non-json response return the Response object.\n    // This to let users decide if they want to call text(), blob() or\n    // something else on it\n\n\n    if (body === undefined) {\n      return res;\n    } // Otherwise just return the parsed body (can also be \"\" or null)\n\n\n    return body;\n  });\n}\n\nexports.request = request;\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\n\nfunction getAndCache(url, requestOptions, force = process.env.NODE_ENV === \"test\") {\n  if (force || !cache[url]) {\n    cache[url] = request(url, requestOptions);\n    return cache[url];\n  }\n\n  return Promise.resolve(cache[url]);\n}\n\nexports.getAndCache = getAndCache;\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\n\nfunction fetchConformanceStatement(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n  return getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the conformance statement from \"${url}\". ${ex}`);\n  });\n}\n\nexports.fetchConformanceStatement = fetchConformanceStatement;\n/**\n * Given a response object, generates and throws detailed HttpError.\n * @param resp The `Response` object of a failed `fetch` request\n */\n\nasync function humanizeError(resp) {\n  let msg = `${resp.status} ${resp.statusText}\\nURL: ${resp.url}`;\n  let body = null;\n\n  try {\n    const type = resp.headers.get(\"Content-Type\") || \"text/plain\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      body = await resp.json();\n\n      if (body.error) {\n        msg += \"\\n\" + body.error;\n\n        if (body.error_description) {\n          msg += \": \" + body.error_description;\n        }\n      } else {\n        msg += \"\\n\\n\" + JSON.stringify(body, null, 4);\n      }\n    } else if (type.match(/^text\\//i)) {\n      body = await resp.text();\n\n      if (body) {\n        msg += \"\\n\\n\" + body;\n      }\n    }\n  } catch (_) {// ignore\n  }\n\n  throw new HttpError_1.default(msg, resp.status, resp.statusText, body);\n}\n\nexports.humanizeError = humanizeError;\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\n\nfunction getPath(obj, path = \"\") {\n  path = path.trim();\n\n  if (!path) {\n    return obj;\n  }\n\n  let segments = path.split(\".\");\n  let result = obj;\n\n  while (result && segments.length) {\n    const key = segments.shift();\n\n    if (!key && Array.isArray(result)) {\n      return result.map(o => getPath(o, segments.join(\".\")));\n    } else {\n      result = result[key];\n    }\n  }\n\n  return result;\n}\n\nexports.getPath = getPath;\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\n\nfunction setPath(obj, path, value, createEmpty = false) {\n  path.trim().split(\".\").reduce((out, key, idx, arr) => {\n    if (out && idx === arr.length - 1) {\n      out[key] = value;\n    } else {\n      if (out && out[key] === undefined && createEmpty) {\n        out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n      }\n\n      return out ? out[key] : undefined;\n    }\n  }, obj);\n  return obj;\n}\n\nexports.setPath = setPath;\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\n\nfunction makeArray(arg) {\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n\n  return [arg];\n}\n\nexports.makeArray = makeArray;\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\n\nfunction absolute(path, baseUrl) {\n  if (path.match(/^http/)) return path;\n  if (path.match(/^urn/)) return path;\n  return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\nexports.absolute = absolute;\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\n\nfunction randomString(strLength = 8, charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") {\n  const result = [];\n  const len = charSet.length;\n\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * len)));\n  }\n\n  return result.join(\"\");\n}\n\nexports.randomString = randomString;\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\n\nfunction jwtDecode(token, env) {\n  const payload = token.split(\".\")[1];\n  return payload ? JSON.parse(env.atob(payload)) : null;\n}\n\nexports.jwtDecode = jwtDecode;\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse\n * @param env\n */\n\nfunction getAccessTokenExpiration(tokenResponse, env) {\n  const now = Math.floor(Date.now() / 1000); // Option 1 - using the expires_in property of the token response\n\n  if (tokenResponse.expires_in) {\n    return now + tokenResponse.expires_in;\n  } // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n\n\n  if (tokenResponse.access_token) {\n    let tokenBody = jwtDecode(tokenResponse.access_token, env);\n\n    if (tokenBody && tokenBody.exp) {\n      return tokenBody.exp;\n    }\n  } // Option 3 - if none of the above worked set this to 5 minutes after now\n\n\n  return now + 300;\n}\n\nexports.getAccessTokenExpiration = getAccessTokenExpiration;\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCode(observations, property) {\n  const ret = {};\n\n  function handleCodeableConcept(concept, observation) {\n    if (concept && Array.isArray(concept.coding)) {\n      concept.coding.forEach(({\n        code\n      }) => {\n        if (code) {\n          ret[code] = ret[code] || [];\n          ret[code].push(observation);\n        }\n      });\n    }\n  }\n\n  makeArray(observations).forEach(o => {\n    if (o.resourceType === \"Observation\" && o[property]) {\n      if (Array.isArray(o[property])) {\n        o[property].forEach(concept => handleCodeableConcept(concept, o));\n      } else {\n        handleCodeableConcept(o[property], o);\n      }\n    }\n  });\n  return ret;\n}\n\nexports.byCode = byCode;\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCodes(observations, property) {\n  const bank = byCode(observations, property);\n  return (...codes) => codes.filter(code => code + \"\" in bank).reduce((prev, code) => prev.concat(bank[code + \"\"]), []);\n}\n\nexports.byCodes = byCodes;\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\n\nfunction getPatientParam(conformance, resourceType) {\n  // Find what resources are supported by this server\n  const resources = getPath(conformance, \"rest.0.resource\") || []; // Check if this resource is supported\n\n  const meta = resources.find(r => r.type === resourceType);\n\n  if (!meta) {\n    throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n  } // Check if any search parameters are available for this resource\n\n\n  if (!Array.isArray(meta.searchParam)) {\n    throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n  } // This is a rare case but could happen in generic workflows\n\n\n  if (resourceType == \"Patient\" && meta.searchParam.find(x => x.name == \"_id\")) {\n    return \"_id\";\n  } // Now find the first possible parameter name\n\n\n  const out = settings_1.patientParams.find(p => meta.searchParam.find(x => x.name == p)); // If there is no match\n\n  if (!out) {\n    throw new Error(\"I don't know what param to use for \" + resourceType);\n  }\n\n  return out;\n}\n\nexports.getPatientParam = getPatientParam;\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\n\nasync function getTargetWindow(target, width = 800, height = 720) {\n  // The target can be a function that returns the target. This can be\n  // used to open a layer pop-up with an iframe and then return a reference\n  // to that iframe (or its name)\n  if (typeof target == \"function\") {\n    target = await target();\n  } // The target can be a window reference\n\n\n  if (target && typeof target == \"object\") {\n    return target;\n  } // At this point target must be a string\n\n\n  if (typeof target != \"string\") {\n    _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n\n    return self;\n  } // Current window\n\n\n  if (target == \"_self\") {\n    return self;\n  } // The parent frame\n\n\n  if (target == \"_parent\") {\n    return parent;\n  } // The top window\n\n\n  if (target == \"_top\") {\n    return top;\n  } // New tab or window\n\n\n  if (target == \"_blank\") {\n    let error,\n        targetWindow = null;\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps window.open was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Popup window\n\n\n  if (target == \"popup\") {\n    let error,\n        targetWindow = null; // if (!targetWindow || targetWindow.closed) {\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\"height=\" + height, \"width=\" + width, \"menubar=0\", \"resizable=1\", \"status=0\", \"top=\" + (screen.height - height) / 2, \"left=\" + (screen.width - width) / 2].join(\",\"));\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps the popup window was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Frame or window by name\n\n\n  const winOrFrame = frames[target];\n\n  if (winOrFrame) {\n    return winOrFrame;\n  }\n\n  _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n\n  return self;\n}\n\nexports.getTargetWindow = getTargetWindow;"]},"metadata":{},"sourceType":"script"}