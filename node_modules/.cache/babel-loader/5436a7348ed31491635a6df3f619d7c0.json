{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n * @param [_noRedirect] If true, resolve with the redirect url without trying to redirect to it\n */\n\nasync function authorize(env, params = {}, _noRedirect = false) {\n  // Obtain input\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const url = env.getUrl();\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (_noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  if (!key) {\n    throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n  } // Check if we have a previous state\n\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  if (!state) {\n    throw new Error(\"No state found! Please (re)launch the app.\");\n  } // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    if (!code) {\n      throw new Error(\"'code' url parameter is required\");\n    }\n\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n\n    if (!tokenResponse.access_token) {\n      throw new Error(\"Failed to obtain access token.\");\n    } // Now we need to determine when is this authorization going to expire\n\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n\n  if (!redirectUri) {\n    throw new Error(\"Missing state.redirectUri\");\n  }\n\n  if (!tokenUri) {\n    throw new Error(\"Missing state.tokenUri\");\n  }\n\n  if (!clientId) {\n    throw new Error(\"Missing state.clientId\");\n  }\n\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;","map":{"version":3,"sources":["C:/Users/abhijith.ponnapally/smart-react-app-template/node_modules/fhirclient/lib/smart.js"],"names":["Object","defineProperty","exports","value","init","ready","buildTokenRequest","completeAuth","onMessage","isInPopUp","isInFrame","authorize","getSecurityExtensions","fetchWellKnownJson","KEY","lib_1","require","Client_1","settings_1","enumerable","get","SMART_KEY","debug","extend","isBrowser","window","baseUrl","requestOptions","url","String","replace","getAndCache","catch","ex","Error","message","getSecurityExtensionsFromWellKnownJson","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","getSecurityExtensionsFromConformanceStatement","fetchConformanceStatement","nsUri","extensions","getPath","filter","e","map","o","extension","out","forEach","ext","valueUri","any","tasks","len","length","errors","resolved","Promise","resolve","reject","onSuccess","task","result","complete","t","controller","abort","onError","error","push","join","promise","env","AbortController","getAbortController","abortController1","abortController2","signal","params","_noRedirect","redirect_uri","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","target","width","height","iss","launch","fhirServiceUrl","redirectUri","scope","clientId","completeInTarget","getUrl","storage","getStorage","searchParams","relative","match","serverUrl","inFrame","inPopUp","console","warn","oldKey","unset","stateKey","randomString","state","tokenResponse","key","fullSessionStorageSupport","set","assign","patient","encounter","redirectUrl","encodeURIComponent","redirect","redirectParams","win","getTargetWindow","self","sessionStorage","removeItem","setItem","JSON","stringify","location","href","addEventListener","top","parent","opener","name","data","type","origin","URL","removeEventListener","_a","_b","Storage","code","authError","authErrorDescription","Boolean","postMessage","close","delete","hasState","has","history","replaceState","authorized","access_token","request","expiresAt","getAccessTokenExpiration","client","default","method","headers","body","Authorization","btoa","options","cached"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n * @param [_noRedirect] If true, resolve with the redirect url without trying to redirect to it\n */\n\nasync function authorize(env, params = {}, _noRedirect = false) {\n  // Obtain input\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const url = env.getUrl();\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (_noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  if (!key) {\n    throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n  } // Check if we have a previous state\n\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  if (!state) {\n    throw new Error(\"No state found! Please (re)launch the app.\");\n  } // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    if (!code) {\n      throw new Error(\"'code' url parameter is required\");\n    }\n\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n\n    if (!tokenResponse.access_token) {\n      throw new Error(\"Failed to obtain access token.\");\n    } // Now we need to determine when is this authorization going to expire\n\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n\n  if (!redirectUri) {\n    throw new Error(\"Missing state.redirectUri\");\n  }\n\n  if (!tokenUri) {\n    throw new Error(\"Missing state.tokenUri\");\n  }\n\n  if (!clientId) {\n    throw new Error(\"Missing state.clientId\");\n  }\n\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;"]},"metadata":{},"sourceType":"script"}