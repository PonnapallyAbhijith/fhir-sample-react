{"ast":null,"code":"import { ALL_RESOURCES_PATIENT_REFERENCE } from './patient';\nimport { mappers } from 'fhir-mapper';\nimport config from './ConfigManager';\nconst mapperName = config.get('mapper');\nconst MapperClass = mappers[mapperName];\nconst mapperInstance = MapperClass ? new MapperClass() : null;\n\nconst applyMapping = bundle => {\n  if (mapperInstance && bundle) {\n    bundle = mapperInstance.execute(bundle);\n  }\n\n  return bundle;\n};\n/**\r\n * There are slight discrepencies between the $everything, revinclude, and manual methods that affect the resources that might be returned\r\n * @param {Object} client - the fhir client\r\n */\n\n\nfunction getPatientRecord(client) {\n  return client.request(`/metadata`).then(statement => {\n    if (statement.rest[0].operation.find(e => (e.definition.reference || e.definition) === 'OperationDefinition/Patient--everything')) {\n      // supports patient everything\n      return getEverything(client).then(bundle => applyMapping(bundle));\n    } else {\n      console.log('Cannot use $everything, using reverse includes instead');\n      const supportedResources = [];\n      let revIncludeResources = [];\n      statement.rest[0].resource.forEach(resource => {\n        if (resource.type === 'Patient') {\n          if (resource.searchRevInclude) {\n            revIncludeResources = resource.searchRevInclude;\n          }\n        } else if (resource.searchInclude) {\n          const filters = resource.searchInclude.filter(target => {\n            return target === `${resource.type}:patient` || target === `${resource.type}:subject`;\n          });\n\n          if (filters.length > 0) {\n            supportedResources.push(filters[0]);\n          }\n        } else if (resource.searchParam) {\n          const filters = resource.searchParams.filter(target => {\n            return target.name === `patient` || target.name === `subject`;\n          });\n\n          if (filters.length > 0) {\n            supportedResources.push(`${resource.type}:${filters[0].name}`);\n          }\n        }\n      });\n\n      if (revIncludeResources.length > 0) {\n        return getEverythingRevInclude(client, revIncludeResources, getEverythingManually).then(bundle => applyMapping(bundle));\n      } else if (supportedResources.length > 0) {\n        return getEverythingRevInclude(client, supportedResources, getEverythingManually).then(bundle => applyMapping(bundle));\n      } else {\n        console.log('Cannot use reverse includes, retrieving all resources manually from predefined list');\n        return getEverythingManually(client, ALL_RESOURCES_PATIENT_REFERENCE).then(bundle => applyMapping(bundle));\n      }\n    }\n  });\n}\n/**\r\n * Uses the $everything operation.  The server takes care of constructing the bundle that gets returned, so\r\n * it is generally not possible to know how it is deciding what resources to send.\r\n */\n\n\nfunction getEverything(client) {\n  return client.request(`/Patient/${client.patient.id}/$everything`, {\n    flat: true,\n    pageLimit: 0\n  }).then(bundle => {\n    return bundle;\n  });\n}\n/**\r\n * Uses regular FHIR search queries on every resource that is supported and can refer to a patient.\r\n * Which resources it queries is dependent on info available in the Capability Statement, and\r\n * it only provides a one layer deep search, so the results might be different from $everything.\r\n */\n\n\nfunction getEverythingManually(client, supportedResources) {\n  supportedResources.push('Patient:_id');\n  const requests = [];\n  supportedResources.forEach(resource => {\n    resource = resource.split(':');\n    const request = client.request(`${resource[0]}?${resource[1]}=${client.patient.id}`, {\n      flat: true,\n      pageLimit: 0\n    }).then(result => {\n      if (result.length > 0) {\n        return result;\n      }\n    }).catch(error => {\n      console.log(`failed to fetch ${resource}`);\n      console.error(error);\n    });\n    requests.push(request);\n  });\n  return Promise.all(requests).then(results => {\n    const bundle = results.filter(x => {\n      return x;\n    }).flat();\n    return bundle;\n  });\n}\n/**\r\n * Uses the _revinclude FHIR search parameter to request the patient resource and any resource that refers to it.\r\n * The list of resources it checks is retrieved from the Capability Statement.  It is slightly better than the manual\r\n * method since it does everything in one request.\r\n */\n\n\nfunction getEverythingRevInclude(client, supportedResources, onError) {\n  const query = supportedResources.join('&_revinclude=');\n  return client.request(`/Patient?_id=${client.patient.id}&_revinclude=${query}`, {\n    flat: true\n  }).then(result => {\n    return result;\n  }).catch(error => {\n    console.log('Reverse Include query failed, manually fetching resources instead.');\n    console.error(error);\n    onError(client, supportedResources);\n  });\n}\n\nexport { getPatientRecord };","map":{"version":3,"sources":["C:/Users/abhijith.ponnapally/smart-react-app-template/src/utils/fhirExtract.js"],"names":["ALL_RESOURCES_PATIENT_REFERENCE","mappers","config","mapperName","get","MapperClass","mapperInstance","applyMapping","bundle","execute","getPatientRecord","client","request","then","statement","rest","operation","find","e","definition","reference","getEverything","console","log","supportedResources","revIncludeResources","resource","forEach","type","searchRevInclude","searchInclude","filters","filter","target","length","push","searchParam","searchParams","name","getEverythingRevInclude","getEverythingManually","patient","id","flat","pageLimit","requests","split","result","catch","error","Promise","all","results","x","onError","query","join"],"mappings":"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","sourcesContent":["import { ALL_RESOURCES_PATIENT_REFERENCE } from './patient';\r\n\r\nimport { mappers } from 'fhir-mapper';\r\nimport config from './ConfigManager';\r\n\r\nconst mapperName = config.get('mapper');\r\nconst MapperClass = mappers[mapperName];\r\nconst mapperInstance = MapperClass ? new MapperClass() : null;\r\n\r\nconst applyMapping = (bundle) => {\r\n  if (mapperInstance && bundle)\r\n  {\r\n    bundle = mapperInstance.execute(bundle);\r\n  }\r\n  return bundle;\r\n}\r\n\r\n/**\r\n * There are slight discrepencies between the $everything, revinclude, and manual methods that affect the resources that might be returned\r\n * @param {Object} client - the fhir client\r\n */\r\nfunction getPatientRecord(client) {\r\n  return client.request(`/metadata`).then(statement => {\r\n    if (\r\n      statement.rest[0].operation.find(\r\n        e => (e.definition.reference || e.definition) === 'OperationDefinition/Patient--everything'\r\n      )\r\n    ) {\r\n      // supports patient everything\r\n      return getEverything(client).then(bundle => applyMapping(bundle));\r\n    } else {\r\n      console.log('Cannot use $everything, using reverse includes instead');\r\n      const supportedResources = [];\r\n      let revIncludeResources = [];\r\n      statement.rest[0].resource.forEach(resource => {\r\n        if (resource.type === 'Patient') {\r\n          if (resource.searchRevInclude) {\r\n            revIncludeResources = resource.searchRevInclude;\r\n          }\r\n        } else if (resource.searchInclude) {\r\n          const filters = resource.searchInclude.filter(target => {\r\n            return target === `${resource.type}:patient` || target === `${resource.type}:subject`;\r\n          });\r\n          if (filters.length > 0) {\r\n            supportedResources.push(filters[0]);\r\n          }\r\n        } else if (resource.searchParam) {\r\n          const filters = resource.searchParams.filter(target => {\r\n            return target.name === `patient` || target.name === `subject`;\r\n          });\r\n          if (filters.length > 0) {\r\n            supportedResources.push(`${resource.type}:${filters[0].name}`);\r\n          }\r\n        }\r\n      });\r\n      if (revIncludeResources.length > 0) {\r\n        return getEverythingRevInclude(client, revIncludeResources, getEverythingManually).then(bundle => applyMapping(bundle));\r\n      } else if (supportedResources.length > 0) {\r\n        return getEverythingRevInclude(client, supportedResources, getEverythingManually).then(bundle => applyMapping(bundle));\r\n      } else {\r\n        console.log('Cannot use reverse includes, retrieving all resources manually from predefined list');\r\n        return getEverythingManually(client, ALL_RESOURCES_PATIENT_REFERENCE).then(bundle => applyMapping(bundle));\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Uses the $everything operation.  The server takes care of constructing the bundle that gets returned, so\r\n * it is generally not possible to know how it is deciding what resources to send.\r\n */\r\nfunction getEverything(client) {\r\n  return client.request(`/Patient/${client.patient.id}/$everything`, { flat: true, pageLimit: 0 }).then(bundle => {\r\n    return bundle;\r\n  });\r\n}\r\n\r\n/**\r\n * Uses regular FHIR search queries on every resource that is supported and can refer to a patient.\r\n * Which resources it queries is dependent on info available in the Capability Statement, and\r\n * it only provides a one layer deep search, so the results might be different from $everything.\r\n */\r\nfunction getEverythingManually(client, supportedResources) {\r\n  supportedResources.push('Patient:_id');\r\n  const requests = [];\r\n  supportedResources.forEach(resource => {\r\n    resource = resource.split(':');\r\n    const request = client\r\n      .request(`${resource[0]}?${resource[1]}=${client.patient.id}`, { flat: true, pageLimit: 0 })\r\n      .then(result => {\r\n        if (result.length > 0) {\r\n          return result;\r\n        }\r\n      })\r\n      .catch(error => {\r\n        console.log(`failed to fetch ${resource}`);\r\n        console.error(error);\r\n      });\r\n    requests.push(request);\r\n  });\r\n\r\n  return Promise.all(requests).then(results => {\r\n    const bundle = results\r\n      .filter(x => {\r\n        return x;\r\n      })\r\n      .flat();\r\n    return bundle;\r\n  });\r\n}\r\n\r\n/**\r\n * Uses the _revinclude FHIR search parameter to request the patient resource and any resource that refers to it.\r\n * The list of resources it checks is retrieved from the Capability Statement.  It is slightly better than the manual\r\n * method since it does everything in one request.\r\n */\r\nfunction getEverythingRevInclude(client, supportedResources, onError) {\r\n  const query = supportedResources.join('&_revinclude=');\r\n  return client\r\n    .request(`/Patient?_id=${client.patient.id}&_revinclude=${query}`, { flat: true })\r\n    .then(result => {\r\n      return result;\r\n    })\r\n    .catch(error => {\r\n      console.log('Reverse Include query failed, manually fetching resources instead.');\r\n      console.error(error);\r\n      onError(client, supportedResources);\r\n    });\r\n}\r\n\r\nexport { getPatientRecord };\r\n"]},"metadata":{},"sourceType":"module"}